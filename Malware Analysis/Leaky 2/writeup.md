after getting the target `notepad.exe` process id it will be assigned to the variable `v3` 

after this it checks if the v3 is not zero and if it does it will call the windows 32 api function `openProcess` with the `v3` as the third argument and it will return a handle to the `notepad.exe` process.

**handle** is a unique identifier or reference used by the operating system to represent and manipulate resources such as files, processes, or objects

after this it will check if the openProcess successfully got a handle to the target process and if it does it will call the function `sub_140001120` with arguments `v4` which is the handle to **notepad.exe** and the second argument is `&unk_14001E000` which is the **encrypted shellcode buffer** and the third argument is `nSize` which is the **encrypted shellcode size**

[![image.png](https://i.postimg.cc/GtF8wjYM/image.png)](https://postimg.cc/RJ0VwKgf)

if you want to view what is the encrypted shellcode size for exemple you can double click on nSize and you will get a hex value

[![image.png](https://i.postimg.cc/ydNvNknX/image.png)](https://postimg.cc/KKdnqc6R)

[![image.png](https://i.postimg.cc/K82X8DTP/image.png)](https://postimg.cc/0bcXtmcj)

the same goes for the encrypted shellcode

now let's double click on the function `sub_140001120` 

[![image.png](https://i.postimg.cc/zGrn2ymD/image.png)](https://postimg.cc/1fvnf55b)

first thing it allocates a virtual memory in the target process `notepad.exe` using the windows api function `VirtualAllocEx` and it sets the memory allocated to be exactly the encrypted shellcode size and the allocation type to be `MEM_COMMIT` and the flProtect to be `PAGE_EXECUTE_READ` and the variable `v6` holds the handle to the virtual memory allocated

[![image.png](https://i.postimg.cc/bwZjMw1M/image.png)](https://postimg.cc/fVQFSZ2j)

[![image.png](https://i.postimg.cc/44WqgT4T/image.png)](https://postimg.cc/fk0Bcp0H)

you can view the `VirtualAllocEx` arguments values here 
https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex

and then we can see that it calls the function `sub_140001000` and it passes to it the **encrypted shellcode buffer** and the the **encrypted shellcode size** and the String aSayonara129 which holds the string value `sayonara129` and the last argument is the size of the string `0C` which is 12 in decimal 

[![![image.png](https://i.postimg.cc/ZKGhGhj5/image.png)](https://postimg.cc/SJf593wB)

before jumping to the function and see its functionality we can see that the function `WriteProcessMemory` is called after which writes the shellcode buffer into the allocated memory using `VirtualAllocEx` and that means that the shellcode buffer injected into the allocated memory is the decrypted shellcode which is obvious because executing encrypted shellcode will not be meaningful so we can assume that the function `sub_140001000` is trying to decrypt the encrypted shellcode using the key `sayonara129`.

to make sure let's analyze the function `sub_140001000`. double click on it to view it

[![image.png](https://i.postimg.cc/s2VS4qkT/image.png)](https://postimg.cc/TK4pR7Yb)

this code is looping through the buffer base on its size and it's xoring each byte with the corresponding byte in the string **aSayonara129** which holds the value `sayonara129` and it keeps repeating the key if it's shorter than the shellcode buffer.

if it's hard to analyze you can always ask chat gpt

[![image.png](https://i.postimg.cc/Y9zsy50j/image.png)](https://postimg.cc/G89K4Sk1)

that means that the function is decrypting the encrypted shellcode buffer by xoring it with the key `sayonara129` and after its being decrypted its injected into the allocated memory, and then executed using a remote thread by the windows api function `CreateRemoteThread`

so the key is `sayonara129`

## Flag : 

```
DEFENSYS{sayonara129}
```
